/* this is for reference, we start from these targets
direct_SQL_data_statement ::=
// delete_statement:_searched
		delete_statement
// direct_select_statement:_multiple_rows
	|	select_statement
	|	insert_statement
// update_statement:_searched
	|	update_statement
// to be supported in the next version
	|	merge_statement
// not supported
	|	temporary_table_declaration
*/

interface select_statement<T> (Query<T>) ;

class SelectStatement<T> implements select_statement<T> with sqlBuilder
import java.util.List;
import java.util.LinkedList;
import java.sql.SQLException;
{
    // TODO add scroll
    public List<T> list(final Database database)  throws SQLException {
        final SqlContext context = new SqlContext();
        context.set(FromClause.class, new FromClause());
        context.set(ColumnNameProvider.class, new ColumnNameProvider());
        this.z$prepare$select_statement(context);
        final List<T> list = new LinkedList<T>();
        final Query<T> query = this.z$create$select_statement(context);
        database.query(query, new IteratorCallback<Row>() {
            public int iterate(final Row row) throws SQLException {
                list.add(query.extract(row));
                return 1;
            }
        });
        return list;
    }
}
;


/*
direct_select_statement:_multiple_rows ::= zCursorSpecification
zCursorSpecification ::= zQueryExpression [ zOrderByClause ] [ updatability_clause ]
updatability_clause ::= FOR { READ ONLY | UPDATE [ OF column_name_list ] }

Simqle re-defines this in the following way:
updateability_clause moves to select_statement;
OF column_name_list is not supported in the current version (0.7)
*/
<T> select_statement<T> ::= zCursorSpecification<T>
    ( SelectStatement<T> ::= CursorSpecification<T> )

| zCursorSpecification<T>  FOR READ ONLY
    ( + CursorSpecification<T> )
    {
        public SelectStatement<T> forReadOnly() {
            final SqlFactory factory = SqlFactory.getInstance();
            return new SelectStatement<T>(factory._THIS_PRODUCTION_(this));
        }
    }

| zCursorSpecification<T> FOR UPDATE
    ( + CursorSpecification<T> )
    {
        public SelectStatement<T> forUpdate() {
            final SqlFactory factory = SqlFactory.getInstance();
            return new SelectStatement<T>(factory._THIS_PRODUCTION_(this));
        }
    }
;

interface zCursorSpecification<T> (Query<T>) ;

class CursorSpecification<T> implements zCursorSpecification<T> with sqlBuilder
import java.util.List;
import java.sql.SQLException;
{};

/*
zCursorSpecification ::= zQueryExpression [ zOrderByClause ] [ updatability_clause ]
updatability_clause moved to select_statement
zCursorSpecification_scalar introduced
*/

<T> zCursorSpecification<T> ::= zCursorSpecification_scalar<T>
    ( CursorSpecification<T> ::= CursorSpecificationScalar<T> )

| zQueryExpression<T>
      ( CursorSpecification<T> ::= QueryExpression<T> )

| zQueryExpression<T> zOrderByClause
        ( + QueryExpression<T> )
        {
            // TODO: add arguments and implement
            CursorSpecification<T> orderBy() {
                throw new RuntimeException("FIXME");
            }
        }
;


interface zCursorSpecification_scalar<T> (Query<T>) extends Scalar<T> ;

class CursorSpecificationScalar<T> implements zCursorSpecification_scalar<T> with sqlBuilder
import java.util.List;
import java.sql.SQLException;
{};

interface zQueryExpression<T> (Query<T>) ;

class QueryExpression<T> implements zQueryExpression<T> with sqlBuilder
import java.util.List;
import java.sql.SQLException;
{};


/*
zQueryExpressionScalar introduced
It does not have its own orderBy;
 it is inherited from zQueryExpression
 ( and scalar context is lost)

*/
<T> zCursorSpecification_scalar<T> ::= zQueryExpressionScalar<T>
      ( CursorSpecificationScalar<T> ::= QueryExpressionScalar<T> )

| zQueryExpressionScalar<T> zOrderByClause
        ( + QueryExpressionScalar<T> )
        {
            // TODO: add arguments and implement
            CursorSpecificationScalar<T> orderBy() {
                throw new RuntimeException("FIXME");
            }
        }
;


interface zQueryExpressionScalar<T> (Query<T>) extends Scalar<T> ;

class QueryExpressionScalar<T> implements zQueryExpressionScalar<T> with sqlBuilder
import java.util.List;
import java.sql.SQLException;
{};

/*
zQueryExpression ::= [ with_clause ] zQueryExpression_body
zQueryExpression_body ::= non-join_zQueryExpression | zTableJoin

with_clause and zTableJoin are not supported (not needed)
union, intersect and except are supported only for scalars
so, the syntax is simplified
*/


<T> zQueryExpression<T> ::= zQueryExpressionScalar<T>
    ( QueryExpression<T> ::= QueryExpressionScalar<T> )

|  zQueryPrimary<T>
    ( QueryExpression<T> ::= QueryPrimary<T> )
;

/*
non-join_zQueryExpression ::=
		non-join_zQueryTerm
	|	zQueryExpression_body UNION [ ALL | DISTINCT ] [ corresponding_spec ] zQueryTerm
	|	zQueryExpression_body EXCEPT [ ALL | DISTINCT ] [ corresponding_spec ] zQueryTerm
*/

<T> zQueryExpressionScalar<T> ::= zQueryTerm<T>
    ( QueryExpressionScalar<T> ::= QueryTerm<T> )

|    zQueryExpressionScalar<T> UNION ALL zQueryTerm<T>
    ( + QueryExpressionScalar<T> )
    {
    public QueryExpressionScalar<T> unionAll(zQueryTerm<T> queryTerm) {
        return new QueryExpressionScalar<T>(
            SqlFactory.getInstance()._THIS_PRODUCTION_(this, queryTerm)
            );
        }
    }

|    zQueryExpressionScalar<T> UNION DISTINCT zQueryTerm<T>
    ( + QueryExpressionScalar<T> )
    {
    public QueryExpressionScalar<T> unionDistinct(zQueryTerm<T> queryTerm) {
        return new QueryExpressionScalar<T>(
            SqlFactory.getInstance()._THIS_PRODUCTION_(this, queryTerm)
            );
        }
    }

|    zQueryExpressionScalar<T> EXCEPT ALL zQueryTerm<T>
    ( + QueryExpressionScalar<T> )
    {
    public QueryExpressionScalar<T> exceptAll(zQueryTerm<T> queryTerm) {
        return new QueryExpressionScalar<T>(
            SqlFactory.getInstance()._THIS_PRODUCTION_(this, queryTerm)
            );
        }
    }

|    zQueryExpressionScalar<T> EXCEPT DISTINCT zQueryTerm<T>
    ( + QueryExpressionScalar<T> )
    {
    public QueryExpressionScalar<T> exceptDistinct(zQueryTerm<T> queryTerm) {
        return new QueryExpressionScalar<T>(
            SqlFactory.getInstance()._THIS_PRODUCTION_(this, queryTerm)
            );
        }
    }
;

interface zQueryTerm<T> (Query<T>) extends Scalar<T> ;

class QueryTerm<T> implements zQueryTerm<T> with SqlBuilder
 import java.util.List;
 import java.sql.SQLException;
{};

<T> zQueryTerm<T> ::= zQueryPrimaryScalar<T>
    ( QueryTerm<T> ::= QueryPrimaryScalar<T> )

|   zQueryTerm<T> INTERSECT ALL zQueryPrimaryScalar<T>
    ( + QueryTerm<T> )
     {
         public QueryTerm<T> intersectAll(final zQueryPrimaryScalar<T> qps) {
            return new QueryTerm<T>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, qps));
         }
     }

|   zQueryTerm<T> INTERSECT DISTINCT zQueryPrimaryScalar<T>
    ( + QueryTerm<T> )
     {
         public QueryTerm<T> intersectDistinct(final zQueryPrimaryScalar<T> qps) {
            return new QueryTerm<T>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, qps));
         }
     }
;

interface zQueryPrimary<T> (Query<T>) ;
class QueryPrimary<T> implements zQueryPrimary<T> with sqlBuilder
 import java.util.List;
 import java.sql.SQLException;
{};

/*
zQueryPrimary ::= non-join_zQueryPrimary | zTableJoin

non-join_zQueryPrimary ::= simple_table | left_paren non-join_zQueryExpression right_paren

simple_table ::=
		query_specification
	|	table_value_constructor
	|	explicit_table
Only simple_table -> query_specification is supported
*/

<T> zQueryPrimary<T> ::= query_specification<T>
    ( QueryPrimary<T> ::= QuerySpecification<T> )
;


interface zQueryPrimaryScalar<T> (Query<T>) extends Scalar<T> ;

class QueryPrimaryScalar<T> implements zQueryPrimaryScalar<T> with sqlBuilder ;

<T> zQueryPrimaryScalar<T> ::= zQuerySpecificationScalar<T>
    ( QueryPrimaryScalar<T> ::= QuerySpecificationScalar<T> )

|  LEFT_PAREN zQueryExpressionScalar<T> RIGHT_PAREN
{
public Query<T> z$create$zQueryPrimaryScalar(SqlContext context) {
    final Query<T> base = arg0.z$create$zQueryExpressionScalar(context);
    return new CompoundQuery<T>(base, new CompositeSql(LEFT_PAREN, base, RIGHT_PAREN));
        }
}
    ( QueryPrimaryScalar<T> ::= QueryExpressionScalar<T> )
;


interface query_specification<T> (Query<T>) ;

class QuerySpecification<T> implements query_specification<T> with sqlBuilder ;

interface zQuerySpecificationScalar<T> (Query<T>) extends Scalar<T> ;

class QuerySpecificationScalar<T> implements zQuerySpecificationScalar<T> with sqlBuilder ;

/*
query_specification ::= SELECT [ set_quantifier ] zSelectList table_expression
set_quantifier ::= DISTINCT | ALL


table_expression ::=
		zFromClause
		[ zWhereClause ]
		[ group_by_clause ]
		[ having_clause ]
		[ window_clause ]

This has been reformulated as follows:
1. Remove group_by_clause, having_clause, window_clause - not supported
2. Inline table_expression
query_specification ::= SELECT [ set_quantifier ] zSelectList zFromClause [zWhereClause]
3. Introduce new non-terminal:
zQueryBase ::= SELECT [ set_quantifier ] zSelectList zFromClause
query_specification ::= zQueryBase
 		|  zQueryBase zWhereClause
4. Inline set_quantifier in zQueryBase

Scalar counterparts productions are alike.
*/

<T> query_specification<T> ::= zQueryBase<T>
    ( QuerySpecification<T> ::= QueryBase<T> )

  |  zQueryBase<T> zWhereClause
    ( + QueryBase<T> )
    {
        public QuerySpecification<T> where(zWhereClause condition) {
            return new QuerySpecification<T>(
                SqlFactory.getInstance()._THIS_PRODUCTION_(this, condition)
                );
        }
    }
;

<T> zQuerySpecificationScalar<T> ::= zQueryBaseScalar<T>
    ( QuerySpecificationScalar<T> ::= QueryBaseScalar<T> )

  |  zQueryBaseScalar<T> zWhereClause
    ( + QueryBaseScalar<T> )
    {
        public QuerySpecificationScalar<T> where(zWhereClause condition) {
            return new QuerySpecificationScalar<T>(
                SqlFactory.getInstance()._THIS_PRODUCTION_(this, condition)
                );
        }
    }
;

interface zQueryBase<T> (Query<T>) ;
interface zQueryBaseScalar<T> (Query<T>) extends Scalar<T>;

class QueryBase<T> implements zQueryBase<T> with sqlBuilder;

class QueryBaseScalar<T> implements zQueryBaseScalar<T> with sqlBuilder;

<T> zQueryBase<T> ::= SELECT zSelectList<T> zFromClause
{
public Query<T> z$create$zQueryBase(SqlContext context) {
    final Query<T> selectListQuery = arg0.z$create$zSelectList(context);
    return new CompoundQuery<T>(selectListQuery, new CompositeSql(SELECT, selectListQuery, arg1.z$create$zFromClause(context)));
        }
}
    ( QueryBase<T> ::= RowValue<T> ) {
    // this is a tricky part. The user never supplies zFromClause,
    // we are extracting it from Sqlcontext. So, we have only one argument
    // and can implement it transparently
    // but we have to write code of toQueryBase manually
    // providing an instance of ImplicitFromClause
        private final QueryBase<T> toQueryBase() {
            zFromClause fromClause = new ImplicitFromClause();
            return new QueryBase<T>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, fromClause));
        }
    }

| SELECT ALL zSelectList<T> zFromClause
{
public Query<T> z$create$zQueryBase(SqlContext context) {
    final Query<T> selectListQuery = arg0.z$create$zSelectList(context);
    return new CompoundQuery<T>(selectListQuery, new CompositeSql(SELECT, ALL, selectListQuery, arg1.z$create$zFromClause(context)));
        }
}
     ( + RowValue<T> )
     {
        public QueryBase<T> all() {
            zFromClause fromClause = new ImplicitFromClause();
            return new QueryBase<T>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, fromClause));
        }
     }

| SELECT DISTINCT zSelectList<T> zFromClause
{
public Query<T> z$create$zQueryBase(SqlContext context) {
    final Query<T> selectListQuery = arg0.z$create$zSelectList(context);
    return new CompoundQuery<T>(selectListQuery, new CompositeSql(SELECT, ALL, selectListQuery, arg1.z$create$zFromClause(context)));
        }
}
     ( + RowValue<T> )
     {
        public QueryBase<T> distinct() {
            zFromClause fromClause = new ImplicitFromClause();
            return new QueryBase<T>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, fromClause));
        }
     }
;


/* scalar counterpart of zSelectList is zSelectSublist rather than zSelectList_scalar */

<T> zQueryBaseScalar<T> ::= SELECT zSelectSublist<T> zFromClause
{
public Query<T> z$create$zQueryBaseScalar(SqlContext context) {
    final Query<T> sql0 = arg0.z$create$zSelectSublist(context);
    final Sql sql1 = arg1.z$create$zFromClause(context);
    return new CompoundQuery<T>(sql0, new CompositeSql(SELECT, sql0, sql1));
        }
}
    ( QueryBaseScalar<T> ::= SelectSublist<T> ) {
    // see comments to RowValue#toQueryBase()
        private final QueryBaseScalar<T> toQueryBaseScalar() {
            zFromClause fromClause = new ImplicitFromClause();
            return new QueryBaseScalar<T>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, fromClause));
        }
    }

| SELECT ALL zSelectSublist<T> zFromClause
{
public Query<T> z$create$zQueryBaseScalar(SqlContext context) {
    final Query<T> sql0 = arg0.z$create$zSelectSublist(context);
    final Sql sql1 = arg1.z$create$zFromClause(context);
    return new CompoundQuery<T>(sql0, new CompositeSql(SELECT, ALL, sql0, sql1));
        }
}
     ( + Value<T> )
     {
        public QueryBaseScalar<T> all() {
            zFromClause fromClause = new ImplicitFromClause();
            return new QueryBaseScalar<T>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, fromClause));
        }
     }

| SELECT DISTINCT zSelectSublist<T> zFromClause
{
public Query<T> z$create$zQueryBaseScalar(SqlContext context) {
    final Query<T> sql0 = arg0.z$create$zSelectSublist(context);
    final Sql sql1 = arg1.z$create$zFromClause(context);
    return new CompoundQuery<T>(sql0, new CompositeSql(SELECT, DISTINCT, sql0, sql1));
        }
}
     ( + Value<T> )
     {
        public QueryBaseScalar<T> distinct() {
            zFromClause fromClause = new ImplicitFromClause();
            return new QueryBaseScalar<T>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, fromClause));
        }
     }
;


interface zSelectList<T> (Query<T>) ;

/*
A single class RowValue represents both zSelectList and zRowValueExpression.
A more expressive and neutral name given.
*/

class RowValue<T> implements zSelectList<T> with selectList, zRowValueExpression<T>
 {
    public Sql z$create$zRowValueExpression(final SqlContext context) {
        // This is tricky: we form a new SqlContext without
        // ColumnNameProvider
        // then delegate to selectList
        // with this fake context AS ... are not generate,
        // so we get exactly what we need
        SqlContext fakeContext = new SqlContext();
        fakeContext.set(SqlFactory.class, context.get(SqlFactory.class));
        fakeContext.set(FromClause.class, context.get(FromClause.class));
        return this.selectList.z$create$zSelectList(fakeContext);
    }

    public void z$prepare$zRowValueExpression(final SqlContext context) {
        // same as prepare context wof zSelectList
        z$prepare$zSelectList(context);
    }
}
;


/**
zSelectList ::= asterisk | zSelectSublist [ { comma zSelectSublist }... ]

the first rule is not supported (used internally bypassing the API)
The last one is translated to equivalent non-deterministic rule (but we do not care)
*/

<T> zSelectList<T> ::= zSelectSublist<T>
    ( RowValue<T> ::= SelectSublist<T> )
;

<T,U> zSelectList<Pair<T,U>> ::= zSelectList<T> COMMA zSelectList<U>
{
    public Query<Pair<T,U>> z$create$zSelectList(final SqlContext context) {
        final Query<T> sql0 = arg0.z$create$zSelectList(context);
        final Query<U> sql1 = arg1.z$create$zSelectList(context);
        DataExtractor<Pair<T,U>> extractor = new DataExtractor<Pair<T, U>>() {
            public Pair<T, U> extract(final Row row) throws SQLException {
                final T first = sql0.extract(row);
                final U second = sql1.extract(row);
                return Pair.of(first, second);
            }
        };
        return new CompoundQuery<Pair<T,U>>(extractor, new CompositeSql(sql0, SqlTerminal.COMMA, sql1));
    }
}
 // more naturally implemented as static method of Values class:
 // RowValue<Pair<L,R> pairOf(RowValue<L> l, RowValue<R> r);
 // so no class member method is defined for this production
;

interface zSelectSublist<T> (Query<T>) extends Scalar<T> ;
class SelectSublist<T> implements zSelectSublist<T> with builder;

/*
zSelectSublist ::= derived_column | qualified_asterisk
derived_column ::= value_expression [ as_clause ]
as_clause ::= [ AS ] column_name
column_name ::= identifier

qualified asterisk not used, so we may skip derived_column
inline as_clause, column_name. We may choose to use or not to use AS. Adding it to GenericSqlFactory,
may override in dialects.
*/

<T> zSelectSublist<T> ::= value_expression<T> AS Identifier
{
    public void z$prepare$zSelectSublist(SqlContext context) {
    arg0.z$prepare$value_expression(context);
    }

    public Query<T> _GET_SQL_(SqlContext context) {
        DataExtractor<T> extractor = new DataExtractor<T>() {
            public T extract(final Row row) throws SQLException {
                return value(row.getValue(arg1.toString()));
            }
        };
        return new CompoundQuery<T>(extractor,
            new CompositeSql(arg0.z$create$value_expression(context), SqlTerminal.AS, arg1));
    }
}

|  value_expression<T>
{
public Query<T> _GET_SQL_(SqlContext context) {
    final ColumnNameProvider columnNameProvider = context.get(ColumnNameProvider.class);
        Identifier identifier = columnNameProvider.getUniqueName();
        if (identifier!=null) {
            return zSelectSublist_is_value_expression_AS_Identifier(arg0,
            identifier).z$create$zSelectSublist(context);
        } else {
            return new CompoundQuery<T>(new NullDataExtractor<T>(), arg0.z$create$value_expression(context));
        }
    }
}
    ( SelectSublist<T> ::= Value<T> )
;


#################  stopped here


interface value_expression<T> extends Scalar<T> ; // not Query<T>!


// A single class Value implements both zSelectSublist and value_expressin

class Value<T> implements value_expression<T> with valueExpression ;

/*************

value_expression ::=
		zCommonValueExpression
	|	zBooleanValueExpression
	|	zRowValueExpression
etc.

Simqle syntax is quite different. We do not separate value expression types.
zRowValueExpression is not value_expression. Instead of
zSelectList ::= zSelectSublist ::= zRowValueExpression
we have RowValue<T> extends zRowValueExpression<T> directly - TODO
all zCommonValueExpression are alike, we do not distinct them.
Both zCommonValueExpression
*/

<T> value_expression<T> ::=
		zCommonValueExpression<T>
		( Value<T> ::= CommonValueExpression<T> )

	|	zBooleanValueExpression<T>
	    ( Value<T> ::= BooleanValueExpression<T> )
;

interface zCommonValueExpression<T> extends Scalar<T> ;
class CommonValueExpression<T> implements zCommonValueExpression<T> with sqlBuilder;


/*
 Most instances will be <Boolean>, but SQL allows any valid primary_value_expression
 and database boolean value may be mapped to another type in Java
 */
interface zBooleanValueExpression<T> extends Scalar<T> ;
class BooleanValueExpression<T> implements zBooleanValueExpression<T> with sqlBuilder;


<T> zCommonValueExpression<T> ::=  LEFT_PAREN value_expression<T> RIGHT_PAREN
    ( CommonValueExpression<T> ::= Value<T> )
    | zValueExpressionPrimary<T>
    ( CommonValueExpression<T> ::= ValueExpressionPrimary<T> )
;


/*
For zBooleanValueExpression syntax is very close to sql-2003
But not type paremeters: all methods do not have
type parametes, return type is <Boolean> and arguments are <?>
*/


<T> zBooleanValueExpression<T> ::= zBooleanTerm<T>
		    ( BooleanValueExpression<T> ::= BooleanTerm<T> )
;
zBooleanValueExpression<Boolean> ::=	zBooleanValueExpression<?> OR zBooleanTerm<?>
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
		( + BooleanValueExpression ) {
		    public BooleanValueExpression<Boolean> or(zBooleanTerm<?> term) {
		        return new BooleanValueExpression<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, term));
		    }
		}
;

interface zBooleanTerm<T> extends Scalar<T> ;
class BooleanTerm<T> implements zBooleanTerm<T> with sqlBuilder ;


<T> zBooleanTerm<T> ::= zBooleanFactor<T>
    ( BooleanTerm<T> ::= BooleanFactor<T> )
;
zBooleanTerm<Boolean> ::= zBooleanTerm<?> AND zBooleanFactor<?>
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
	( + BooleanTerm<T> ) {
	    public BooleanTerm<Boolean> and(BooleanFactor<?> factor) {
		        return new BooleanTerm<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, factor));
	    }
	}
;

interface zBooleanFactor<T> extends Scalar<T> ;
class BooleanFactor<T> implements zBooleanFactor<T> with sqlBuilder ;


<T> zBooleanFactor<T> ::= zBooleanTest<T>
    ( BooleanFactor<T> ::= BooleanTest<T> )

  | NOT zBooleanTest<T>
    ( + BooleanTest<T> )
    {
        BooleanFactor<T> negate() {
            return new BooleanFactor<T>(SqlFactory.getInstance()._THIS_PRODUCTION_(this));
        }
    }
;

interface zBooleanTest<T> extends Scalar<T> ;
class BooleanTest<T> implements zBooleanTest<T> with sqlBuilder ;

<T> zBooleanTest<T> ::= zBooleanPrimary<T>
    ( BooleanTest<T> ::= BooleanPrimary<T> )
;

interface zBooleanPrimary<T> extends Scalar<T> ;
class BooleanPrimary<T> implements zBooleanPrimary<T> with sqlBuilder ;



zBooleanTest<Boolean> ::= zBooleanPrimary<?>  IS  NOT  TRUE
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
    ( + BooleanPrimary<T> )
    {
        public BooleanTest<Boolean> isNotTrue() {
            return new BooleanTest<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this));
        }
    }

|  zBooleanPrimary<?>  IS  TRUE
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
    ( + BooleanPrimary<T> )
    {
        public BooleanTest<Boolean> isTrue() {
            return new BooleanTest<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this));
        }
    }

| zBooleanPrimary<?>  IS  NOT  FALSE
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
    ( + BooleanPrimary<T> )
    {
        public BooleanTest<Boolean> isNotFalse() {
            return new BooleanTest<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this));
        }
    }

|  zBooleanPrimary<?>  IS  FALSE
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
    ( + BooleanPrimary<T> )
    {
        public BooleanTest<Boolean> isFalse() {
            return new BooleanTest<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this));
        }
    }

| zBooleanPrimary<?>  IS  NOT  UNKNOWN
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
    ( + BooleanPrimary<T> )
    {
        public BooleanTest<Boolean> isNotUnknown() {
            return new BooleanTest<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this));
        }
    }

|  zBooleanPrimary<?>  IS  UNKNOWN
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
    ( + BooleanPrimary<T> )
    {
        public BooleanTest<Boolean> isUnknown() {
            return new BooleanTest<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this));
        }
    }
;

/*
truth_value ::= TRUE | FALSE | UNKNOWN
*/


/*
zBooleanPrimary ::= zPredicate | boolean_predicand

boolean_predicand ::=
		parenthesized_zBooleanValueExpression
	|	zValueExpressionPrimary

parenthesized_zBooleanValueExpression ::= left_paren zBooleanValueExpression right_paren

simplified by inlining
*/


<T> zBooleanPrimary<T> ::= zPredicate<T>
    ( BooleanPrimary<T> ::= Predicate<T> )
  | LEFT_PAREN zBooleanValueExpression<T> RIGHT_PAREN
    ( BooleanPrimary<T> ::= BooleanValueExpression<T> )
  | zValueExpressionPrimary<T>
    ( BooleanPrimary<T> ::= ValueExpressionPrimary<T> )
;

interface zPredicate<T> extends Scalar<T> ;
class Predicate<T> implements zPredicate<T> with sqlBuilder;

/**
zPredicate ::=
		zComparisonPredicate
	|	between_predicate - full release
	|	zInPredicate
	|	like_predicate - full release
	|	similar_predicate -- not supported by MySql; skipped
	|	zNullPredicate
	|	quantified_zComparisonPredicate - full release
	|	zExistsPredicate
	|	unique_predicate - full release
	|	normalized_predicate - not supported
	|	match_predicate - full release
	|	overlaps_predicate- not supported
	|	distinct_predicate- not supported
	|	member_predicate- not supported
	|	submultiset_predicate- not supported
	|	set_predicate- not supported
	|	type_predicate- not supported
*/

<T> zPredicate<T> ::=
		zComparisonPredicate<T>
		( Predicate<T> ::= ComparisonPredicate<T> )
	|	zInPredicate<T>
		( Predicate<T> ::= InPredicate<T> )
	|	zNullPredicate<T>
		( Predicate<T> ::= NullPredicate<T> )
	|	zExistsPredicate<T>
		( Predicate<T> ::= ExistsPredicate<T> )
;

interface zComparisonPredicate<T> extends Scalar<T> ;
interface zInPredicate<T> extends Scalar<T> ;
interface zNullPredicate<T> extends Scalar<T> ;
interface zExistsPredicate<T> extends Scalar<T> ;

class ComparisonPredicate<T> implements zComparisonPredicate<T> with SqlBuilder;
class InPredicate<T> implements zInPredicate<T> with SqlBuilder;
class NullPredicate<T> implements zNullPredicate<T> with SqlBuilder;
class ExistsPredicate<T> implements zExistsPredicate<T> with SqlBuilder;


/*
zComparisonPredicate ::= zRowValuePredicand zComparisonPredicate_part_2

zComparisonPredicate_part_2 ::= comp_op zRowValuePredicand

comp_op ::=
		equals_operator
	|	not_equals_operator
	|	less_than_operator
	|	greater_than_operator
	|	less_than_or_equals_operator
	|	greater_than_or_equals_operator

*/

zComparisonPredicate<Boolean> ::=
    zRowValuePredicand<?> EQ zRowValuePredicand<?>
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
        ( + RowValuePredicand<T> )
        {
		    public ComparisonPredicate<Boolean> equal(zRowValuePredicand<?> other) {
		        return new ComparisonPredicate<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, other));
		    }
        }
  | zRowValuePredicand<?> NE zRowValuePredicand<?>
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
        ( + RowValuePredicand<T> )
        {
		    public ComparisonPredicate<Boolean> notEqual(zRowValuePredicand<?> other) {
		        return new ComparisonPredicate<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, other));
		    }
        }
  | zRowValuePredicand<?> LT zRowValuePredicand<?>
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
        ( + RowValuePredicand<T> )
        {
		    public ComparisonPredicate<Boolean> less(zRowValuePredicand<?> other) {
		        return new ComparisonPredicate<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, other));
		    }
        }
  | zRowValuePredicand<?> GT zRowValuePredicand<?>
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
        ( + RowValuePredicand<T> )
        {
		    public ComparisonPredicate<Boolean> greater(zRowValuePredicand<?> other) {
		        return new ComparisonPredicate<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, other));
		    }
        }
  | zRowValuePredicand<?> LE zRowValuePredicand<?>
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
        ( + RowValuePredicand<T> )
        {
		    public ComparisonPredicate<Boolean> lessOrEqual(zRowValuePredicand<?> other) {
		        return new ComparisonPredicate<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, other));
		    }
        }
  | zRowValuePredicand<?> GE zRowValuePredicand<?>
		{
            public Boolean value(Element element) throws SQLException {
             return BOOLEAN_SCALAR.value(element);
            }
		}
        ( + RowValuePredicand<T> )
        {
		    public ComparisonPredicate<Boolean> greaterOrEqual(zRowValuePredicand<?> other) {
		        return new ComparisonPredicate<Boolean>(SqlFactory.getInstance()._THIS_PRODUCTION_(this, other));
		    }
        }
;



interface zRowValuePredicand<T> ;
class RowValuePredicand<T> implements zRowValuePredicand with sqlBuilder ;

/*
zRowValuePredicand ::=
		row_value_special_case
	|	row_value_constructor_predicand

row_value_special_case ::= nonparenthesized_zValueExpressionPrimary

row_value_constructor_predicand ::=
		zCommonValueExpression
	|	boolean_predicand
	|	zExplicitRowValueConstructor

Removed unnecessary mediators
zCommonValueExpression<T> includes zValueExpressionPrimary<T>, so "special_case" is covered by it
*/
<T> zRowValuePredicand<T> ::= zCommonValueExpression<T>
    ( RowValuePredicand<T> ::= CommonValueExpression<T> )

    | LEFT_PAREN zBooleanValueExpression<T> RIGHT_PAREN
        ( RowValuePredicand<T> ::= BooleanValueExpression<T> )

	|	zExplicitRowValueConstructor<T>
	    ( RowValuePredicand<T> ::= ExplicitRowValueConstructor<T> )
;


/********** TODO **********/

/*
zRowValueExpression ::=
		row_value_special_case
	|	zExplicitRowValueConstructor

row_value_special_case ::= nonparenthesized_zValueExpressionPrimary

zExplicitRowValueConstructor ::=
		left_paren row_value_constructor_element comma zRowValueConstructorElementList right_paren
	|	ROW left_paren zRowValueConstructorElementList right_paren
	|	row_zSubquery

zRowValueConstructorElementList ::=
		row_value_constructor_element [ { comma row_value_constructor_element }... ]

row_value_constructor_element ::= value_expression

row_zSubquery ::= zSubquery

Changes:
1. inline row_value_special_case, row_value_constructor_element, row_zSubquery
2. change right recursion to left zExplicitRowValueConstructor
3. Allow row_value_constructor_element to be zRowValueConstructorElementList
   and allow both members to be row
We have 2 possibilites for construction of zRowValueExpression from value_expression: as special case and with
ROW. Choosing the first one; the second not needed.

*/

interface zRowValueExpression<T> ;

<T> zRowValueExpression<T> ::= value_expression<T>
    |  zExplicitRowValueConstructor<T> ;

<T,U> zExplicitRowValueConstructor<Pair<T,U>> ::=
		LEFT_PAREN zRowValueConstructorElementList<T> COMMA zRowValueConstructorElementList<U> RIGHT_PAREN
// this is used by Values.pairOf(...) method

	|	zSubquery<T>

;

interface zRowValueConstructorElementList<T> ;
class RowValueConstructorElementList<T> implements zRowValueConstructorElementList<T> with sqlBuilder;

<T> zRowValueConstructorElementList<T> ::= value_expression<T>
    ( RowValueConstructorElementList<T> ::= Value<T> )

  |  zExplicitRowValueConstructor<T>
        (  RowValueConstructorElementList<T> ::= ExplicitRowValueConstructor<T> )
;

interface zExplicitRowValueConstructor<T> ;
class ExplicitRowValueConstructor<T> implements zExplicitRowValueConstructor<T> with sqlBuilder;


interface zValueExpressionPrimary<T> extends Scalar<T> ;
class ValueExpressionPrimary<T> implements zValueExpressionPrimary<T>  with sqlBuilder;

/**************************** TODO *********************/

/*
nonparenthesized_zValueExpressionPrimary ::=
		unsigned_value_specification
	|	column_reference
	|	set_function_specification
	|	window_function
	|	zScalarSubquery
	|	case_expression
	|	cast_specification
	|	field_reference
	|	subtype_treatment
	|	method_invocation
	|	static_method_invocation
	|	new_specification
	|	attribute_or_method_reference
	|	reference_resolution
	|	collection_value_constructor
	|	array_element_reference
	|	multiset_element_reference
	|	zRoutineEnvocation
	|	next_value_expression

*/


<T> zValueExpressionPrimary<T> ::=
		zDynamicParameterSpecification<T>
	|	column_reference<T>
	    (ValueExpressionPrimary<T> ::= Column<T> )
	|	zScalarSubquery<T>
	    ( ValueExpressionPrimary<T> ::= ScalarSubquery<T> )
	|	zRoutineEnvocation<T>
	|	next_value_expression<T>
;

// TODO abstract classes!

interface	zDynamicParameterSpecification<T> extends Scalar<T> ;
abstract class DynamicParameter<T> implements zDynamicParameterSpecification<T> with sqlBuilder;
interface	column_reference<T> extends Scalar<T> ;
abstract class Column<T> implements column_reference<T>
{
    private final Identifier name;
    private final Table owner;

    protected Column(String name, Table owner) {
        this.name = new Identifier(name);
        this.owner = owner;
    }

    public void z$prepare$column_reference(SqlContext context) {
        owner.z$prepare$zTableReference(context);
    }

    /**
     * Defines Sql produced by this syntactic element.
     * Implementations should produce Sql conforming to the productions specified above.
     *
     * @param context - construction context: dialect, tables available in this and enclosing contexts etc.
     * @return sql as required for column_reference syntax
     */
    public Sql z$create$column_reference(SqlContext context) {
        final FromClause fromClause = context.get(FromClause.class);
        final Identifier tableCorrelationName = fromClause.getCorrelationName(owner);
        return new CompositeSql(tableCorrelationName, SqlTerminal.PERIOD, name);
    }
}
;
interface	zScalarSubquery<T> extends Scalar<T> ;
class ScalarSubquery<T> implements zScalarSubquery<T> with sqlBuilder;
interface	zRoutineEnvocation<T>  extends Scalar<T> ;
class RoutineInvocation<T> implements zRoutineEnvocation<T> with sqlBuilder;
interface	next_value_expression<T>  extends Scalar<T> ;
class NextValueExpression<T> implements next_value_expression<T> with sqlBuilder;


<T> zScalarSubquery<T> ::= LEFT_PAREN zQueryExpressionScalar<T> RIGHT_PAREN
{
    public Sql z$create$zScalarSubquery(SqlContext context) {
        SqlContext innerContext = new SqlContext();
        innerContext.set(ColumnNameProvider.class, new NullColumnNameProvider());
        innerContext.set(SqlFactory.class, context.get(SqlFactory.class));
        // create an empty FromClase for zQueryExpressionScalar with current FromClause as enclosing
        innerContext.set(FromClause.class, new FromClause(context.get(FromClause.class)));
        arg0.z$prepare$zQueryExpressionScalar(innerContext);
        final Query<T> base = arg0.z$create$zQueryExpressionScalar(innerContext);
        return new CompoundQuery(base, new CompositeSql(LEFT_PAREN, base, RIGHT_PAREN));
    }

    public void z$prepare$zScalarSubquery(SqlContext context) {
        // do nothing
    }
}
    ( ScalarSubquery<T> ::= QueryExpressionScalar<T> )
;

interface zSubquery<T> ;
class Subquery<T> implements zSubquery<T> with sqlBuilder ;

interface zWhereClause ;

interface zFromClause ;

/*
zFromClause ::= FROM zTableReference_list
zTableReference_list ::= zTableReference [ { comma zTableReference }... ]
zTableReference ::= zTablePrimary_or_zTableJoin [ sample_clause ]
zTablePrimary_or_zTableJoin ::= zTablePrimary | zTableJoin

zTablePrimary ::=
		table_or_query_name [ [ AS ] correlation_name [ left_paren derived_column_list right_paren ] ]
	|	derived_table [ AS ] correlation_name [ left_paren derived_column_list right_paren ]
	|	lateral_derived_table [ AS ] correlation_name [ left_paren derived_column_list right_paren ]
	|	collection_derived_table [ AS ] correlation_name [ left_paren derived_column_list right_paren ]
	|	table_function_derived_table [ AS ] correlation_name [ left_paren derived_column_list right_paren ]
	|	only_spec [ [ AS ] correlation_name [ left_paren derived_column_list right_paren ] ]
	|	left_paren zTableJoin right_paren

zTableJoin ::=
		cross_join
	|	qualified_join
	|	natural_join
	|	union_join

cross_join ::= zTableReference CROSS JOIN zTablePrimary

qualified_join ::= zTableReference [ join_type ] JOIN zTableReference zJoinSpecification

natural_join ::= zTableReference NATURAL [ join_type ] JOIN zTablePrimary

union_join ::= zTableReference UNION JOIN zTablePrimary

*** Changes:
1. implicitt cross joins are not supported, so zTableReference_list can be only zTableReference
2. table_or_query_name is the only supported variant of zTablePrimary
3. qualified_join is re-formulated to contain only table_brinary after join type
4. natural joins are not supported (not needed)
5. union joins are not supported (mostly not supported by popular RDBMS)
6. Sample_clause not supported
7. projections (derived_column_list) not supported
8. table_or_query_name [ [ AS ] correlation_name - both are just Identifier, AS omitted

*/

zFromClause ::= FROM  zTableReference ;
interface zTableReference ;

zTableReference ::=  zTablePrimary
    ( TableReference ::= Table )
     | zTableJoin
     ( TableReference ::= JoinedTable )
;

class TableReference implements zTableReference with builder ;

interface zTablePrimary ;
interface zTableJoin;

class FromClause implements zFromClause
import java.util.*;
import org.simqle.util.TSort;


{

    private final Map<Table, Identifier> localTables = new HashMap<Table, Identifier>();

    private final FromClause enclosingClause;
    private final NameGenerator nameGenerator;

    private int tableCounter = 0;
    private final String correlationNameFormat = "T%d";

    public Identifier getCorrelationName(Table table) {
        if (localTables.containsKey(table)) {
            Identifier name = localTables.get(table);
            if (name==null) {
                name = nameGenerator.generate();
                localTables.put(table, name);
            }
            return name;
        } else if (enclosingClause!=null) {
            return enclosingClause.getCorrelationName(table);
        } else {
            throw new IllegalStateException("Table "+table+" has not been registered in FromClause");
        }
    }

    public FromClause(final FromClause enclosingClause) {
        this.enclosingClause = enclosingClause;
        this.nameGenerator = enclosingClause !=null ? enclosingClause.nameGenerator : new NameGenerator();
    }

    public FromClause() {
        this(null);
     }

    public void z$prepare$zFromClause(SqlContext context) {
        throw new RuntimeException("This code should not be reachable");
    }

    public boolean addTable(Table table) {
        if (!isAvailable(table)) {
            localTables.put(table, null);
            return true;
        } else {
            return false;
        }
    }

    public Sql z$create$zFromClause(final SqlContext context) {
        TSort<Table> tSort = new TSort<Table>();
        // TODO some RDBMS allow emtry FromClause
        if (localTables.size()==0) {
            throw new IllegalStateException("No referenced tables");
        }
        for (Table table: localTables.keySet()) {
            tSort.add(table);

            SqlContext probeContext = new SqlContext();
            probeContext.set(FromClause.class, new FromClause());
            probeContext.set(SqlFactory.class, context.get(SqlFactory.class));
            table.z$prepare$zTableReference(probeContext);
            final Set<Table> dependencies = new HashSet<Table>(
                    probeContext.get(FromClause.class).localTables.keySet()
                    );
            // remove self-dependency
            dependencies.remove(table);
            for (Table dependency: dependencies) {
                tSort.add(table, dependency);
            }
        }
        // TODO better diagnostics on IllegalSTateException
        // cyclic dependency
        final List<Table> sortedTables = tSort.sort();
        zTableReference tableReference = sortedTables.get(0);
        for (int i = 1; i< sortedTables.size(); i++) {
            final Table t = sortedTables.get(i);
            tableReference = t.makeJoinedTable(tableReference);
        }
        // TODO take SqlFactory from the context
        return SqlFactory.getInstance().zFromClause_is_FROM_zTableReference(tableReference).z$create$zFromClause(context);
    }

    private boolean isAvailable(Table table) {
        if (enclosingClause!=null && enclosingClause.isAvailable(table)) {
            return true;
        } else {
            return localTables.containsKey(table);
        }
    }

    private static class NameGenerator {
        private int counter=0;

        private Identifier generate() {
            return new Identifier("T"+(counter++));
        }
    }

}
;

class Table implements zTablePrimary {
    private final Identifier tableOrQueryName;
    public Table(String name) {
        tableOrQueryName = new Identifier(name);
    }
    private enum JoinType {
        cross,
        inner,
        outer,
        left,
        right
    }
    private zJoinSpecification joinSpecification = null;
    private JoinType joinType = null;

    private void setJoinType(JoinType joinType) {
        if (this.joinType!=null) {
            throw new IllegalStateException("Already joined");
        }
        this.joinType = joinType;
    }
    public void joinCross() {
        setJoinType(joinType.cross);
    }
    public void joinLeft(zJoinSpecification joinSpecification) {
        setJoinType(joinType.left);
        this.joinSpecification = joinSpecification;
    }


    public Sql z$create$zTablePrimary(final SqlContext context) {
        final FromClause fromClause = context.get(FromClause.class);
        final Identifier correlationName = fromClause.getCorrelationName(this);
        return new CompositeSql(tableOrQueryName, correlationName);
    }

    protected JoinedTable makeJoinedTable(zTableReference tableReference) {
        if (joinType==null) {
            throw new IllegalStateException("No join defined for this table"+tableOrQueryName);
        }
        final zTableJoin.Builder joinedTableBuilder;
        switch (joinType) {
            case cross:
                joinedTableBuilder = SqlFactory.getInstance().zTableJoin_is_zTableReference_CROSS_JOIN_zTablePrimary(tableReference, this);
                break;
            case left:
                joinedTableBuilder = SqlFactory.getInstance()
                .zTableJoin_is_zTableReference_LEFT_OUTER_JOIN_zTablePrimary_zJoinSpecification(tableReference, this, joinSpecification);
                break;
            default:
                throw new IllegalStateException("Unexpected join type "+joinType);
        }
        return new JoinedTable(joinedTableBuilder);
    }

    public void z$prepare$zTablePrimary(SqlContext context) {
        final FromClause fromClause = context.get(FromClause.class);
        if (fromClause.addTable(this) && joinSpecification!=null) {
            joinSpecification.z$prepare$zJoinSpecification(context);
        }
    }
}
;

# used in Table constructor

zTablePrimary ::= Identifier AS Identifier ;

/*
see Table.join(zTableReference)
*/
zTableJoin ::=
      zTableReference CROSS JOIN zTablePrimary
|     zTableReference INNER JOIN zTablePrimary zJoinSpecification
|     zTableReference OUTER JOIN zTablePrimary zJoinSpecification
|     zTableReference LEFT OUTER JOIN zTablePrimary zJoinSpecification
|     zTableReference RIGHT OUTER JOIN zTablePrimary zJoinSpecification ;


interface zJoinSpecification;

/*
zJoinSpecification ::= join_condition | named_columns_join
join_condition ::= ON search_condition

We do not support named_columns_join
*/

zJoinSpecification ::= ON search_condition
    ( JoinSpecification ::= SearchCondition )
;

class JoinSpecification implements zJoinSpecification with builder;

interface search_condition ;

class SearchCondition implements search_condition with builder;

search_condition ::= zBooleanValueExpression
    ( SearchCondition ::= BooleanValueExpression )
;

class WhereClause implements zWhereClause with builder;

zWhereClause ::= WHERE search_condition
        ( WhereClause ::= SearchCondition )
;



interface zOrderByClause ;

// no class OrderByClause!


# corresponds to direct_select-statement in Sql-2003.2
public interface zSelectStatement<T> : Query<T> {}

class SelectStatement<T> implements zSelectStatement<T> with sqlBuilder
import java.util.List;
import java.util.LinkedList;
import java.sql.SQLException;
{
    // TODO add scroll
    // TODO uncomment when ready (requires FromClause)
    /*
    public List<T> list(final Database database)  throws SQLException {
        final SqlContext context = new SqlContext();
        context.set(FromClause.class, new FromClause());
        context.set(ColumnNameProvider.class, new ColumnNameProvider());
        this.z$prepare$zSelectStatement(context);
        final List<T> list = new LinkedList<T>();
        final Query<T> query = this.z$create$zSelectStatement(context);
        database.query(query, new IteratorCallback<Row>() {
            public int iterate(final Row row) throws SQLException {
                list.add(query.extract(row));
                return 1;
            }
        });
        return list;
    }
    */
public String show() {
    final SqlContext context = new SqlContext();
    context.set(FromClause.class, new FromClause());
    context.set(ColumnNameProvider.class, new ColumnNameProvider());
    context.set(SqlFactory.class, new GenericSqlFactory());
    z$prepare$zSelectStatement(context);
    final String sqlText = z$create$zSelectStatement(context).getSqlText();
    return sqlText.replaceAll("([.(])(\\s+)", "$1").replaceAll("(\\s+)(([.,)(]))", "$2");
}
}



# direct_zSelectStatement:_multiple_rows ::= zCursorSpecification
# zCursorSpecification ::= zQueryExpression [ zOrderByClause ] [ updatability_clause ]
# updatability_clause ::= FOR { READ ONLY | UPDATE [ OF column_name_list ] }

# Simqle re-defines this in the following way:
# updateability_clause moves to zSelectStatement;
# OF column_name_list is not supported in the current version (0.7)

<T> zSelectStatement<T> ::= cspec:zCursorSpecification<T>
    :: CursorSpecification<T> mimics SelectStatement<T> {}

| cspec:zCursorSpecification<T>  FOR READ ONLY
    :: CursorSpecification<T>
    {
        public SelectStatement<T> forReadOnly() {
            return new SelectStatement<T>(_APPLY_RULE_(this));
        }
    }

| cspec:zCursorSpecification<T> FOR UPDATE
    :: CursorSpecification<T>
    {
        public SelectStatement<T> forUpdate() {
            return new SelectStatement<T>(_APPLY_RULE_(this));
        }
    }
;

interface zCursorSpecification<T> : Query<T> {}

class CursorSpecification<T> implements zCursorSpecification<T> with sqlBuilder
{}

#zCursorSpecification ::= zQueryExpression [ zOrderByClause ] [ updatability_clause ]
#updatability_clause moved to zSelectStatement

<T> zCursorSpecification<T> ::= qe:zQueryExpression<T>
    ::  QueryExpression<T> mimics CursorSpecification<T>
    {}

| qe:zQueryExpression<T> obc:zOrderByClause
    :: QueryExpression<T>
        {
            public CursorSpecification<T> orderBy(zSortSpecification sort, zSortSpecification... additionalSort) {
                final SqlFactory factory = SqlFactory.getInstance();
                zSortSpecificationList sortList = factory.zSortSpecificationList_IS_zSortSpecification(sort);
                for (zSortSpecification sortSpec: additionalSort) {
                    sortList = factory.zSortSpecificationList_IS_zSortSpecificationList_COMMA_zSortSpecification(sortList, sortSpec);
                }
                zOrderByClause orderBy = factory.zOrderByClause_IS_ORDER_BY_zSortSpecificationList(sortList);
                return new CursorSpecification<T>(factory.zCursorSpecification_IS_zQueryExpression_zOrderByClause(this, orderBy));
            }
        }
;

public interface zQueryExpression<T> : Query<T>
{}

public class QueryExpression<T> implements zQueryExpression<T> with sqlBuilder
import java.util.List;
import java.sql.SQLException;
{}


public interface zQueryExpressionScalar<T> extends Scalar<T> : Query<T>
{}

public class QueryExpressionScalar<T> implements zQueryExpressionScalar<T> with sqlBuilder
import java.util.List;
import java.sql.SQLException;
{}

# we have different rules for zQueryExpression and zQueryExpression-scalar
# the first one is just zQueryBase with (maybe) where clause
# the second one is really an expression, which may include union, intersection etc.

<T> zQueryExpression<T> ::= qb:zQueryBase<T>
    :: QueryBase<T> mimics QueryExpression<T>
    {}

|   qb:zQueryBase<T> wc:zWhereClause
    :: QueryBase<T>
    {
        public QueryExpression<T> where(zWhereClause condition) {
            return new QueryExpression<T>(_APPLY_RULE_(this, condition));
        }
    }
|   qes:zQueryExpressionScalar<T>
    :: QueryExpressionScalar<T> mimics QueryExpression<T>
    {}
;

<T> zQueryExpressionScalar<T> ::= qt:zQueryTerm<T>
    :: QueryTerm<T> mimics QueryExpressionScalar<T>
     {}

|    qe:zQueryExpressionScalar<T> UNION ALL qt:zQueryTerm<T>
    {
    return new zAbstractQueryExpression<T>(qe, qt, false, true);
    }
    :: QueryExpressionScalar<T>
    {
    public QueryExpressionScalar<T> unionAll(zQueryTerm<T> queryTerm) {
        return new QueryExpressionScalar<T>(_APPLY_RULE_(this, queryTerm));
        }
    }

|    qe:zQueryExpressionScalar<T> UNION DISTINCT qt:zQueryTerm<T>
    {
    return new zAbstractQueryExpression<T>(qe, qt, false, false);
    }
    :: QueryExpressionScalar<T>
    {
    public QueryExpressionScalar<T> unionDistinct(zQueryTerm<T> queryTerm) {
        return new QueryExpressionScalar<T>(_APPLY_RULE_(this, queryTerm));
        }
    }

|    qe:zQueryExpressionScalar<T> EXCEPT ALL qt:zQueryTerm<T>
    {
    return new zAbstractQueryExpression<T>(qe, qt, true, true);
    }
    :: QueryExpressionScalar<T>
    {
    public QueryExpressionScalar<T> exceptAll(zQueryTerm<T> queryTerm) {
        return new QueryExpressionScalar<T>(_APPLY_RULE_(this, queryTerm));
        }
    }

|    qe:zQueryExpressionScalar<T> EXCEPT DISTINCT qt:zQueryTerm<T>
    {
    return new zAbstractQueryExpression<T>(qe, qt, true, false);
    }
    :: QueryExpressionScalar<T>
    {
    public QueryExpressionScalar<T> exceptDistinct(zQueryTerm<T> queryTerm) {
        return new QueryExpressionScalar<T>(_APPLY_RULE_(this, queryTerm));
        }
    }
;

class zAbstractQueryExpression<T> implements zQueryExpressionScalar<T> {
    private final zQueryExpressionScalar<T> qe;
    private final zQueryTerm<T> qt;
    private final SqlTerminal exceptOrUnion;
    private final SqlTerminal allOrDistinct;

    zAbstractQueryExpression$(
        final zQueryExpressionScalar<T> qe,
        final zQueryTerm<T> qt,
        final boolean exceptNotUnion,
        final boolean allNotDistinct
        ) {
        this.qe = qe;
        this.qt = qt;
        this.exceptOrUnion = exceptNotUnion ? SqlTerminal.EXCEPT : SqlTerminal.UNION;
        this.allOrDistinct = allNotDistinct ? SqlTerminal.ALL : SqlTerminal.DISTINCT;
        }


           @Override
           public T value(final Element element) throws SQLException {
                return qe.value(element);
           }
            @Override
            public void z$prepare$zQueryExpressionScalar(final SqlContext context) {
                final SqlContext leftContext = new SqlContext();
                leftContext.set(FromClause.class, new FromClause(context.get(FromClause.class)));
                leftContext.set(ColumnNameProvider.class, new ColumnNameProvider());
                 qe.z$prepare$zQueryExpressionScalar(leftContext);
                final SqlContext rightContext = new SqlContext();
                rightContext.set(FromClause.class, new FromClause(context.get(FromClause.class)));
                rightContext.set(ColumnNameProvider.class, new ColumnNameProvider());
                 qt.z$prepare$zQueryTerm(rightContext);
            }
            @Override
            public Query<T> z$create$zQueryExpressionScalar(final SqlContext context) {
                final SqlContext leftContext = new SqlContext();
                leftContext.set(FromClause.class, new FromClause(context.get(FromClause.class)));
                leftContext.set(ColumnNameProvider.class, new ColumnNameProvider());
                final SqlContext rightContext = new SqlContext();
                rightContext.set(FromClause.class, new FromClause(context.get(FromClause.class)));
                rightContext.set(ColumnNameProvider.class, new ColumnNameProvider());
                 qe.z$prepare$zQueryExpressionScalar(leftContext);
                 qt.z$prepare$zQueryTerm(rightContext);
                return new CompositeQuery<T>(qe.z$create$zQueryExpressionScalar(leftContext), exceptOrUnion, allOrDistinct, qt.z$create$zQueryTerm(rightContext));
            }

}

# zQueryTerm is always scalar; we do not add suffix _scalar for brevity

public interface zQueryTerm<T> extends Scalar<T> :  Query<T>
{}

public class QueryTerm<T> implements zQueryTerm<T> with SqlBuilder
{}

<T> zQueryTerm<T> ::= qp:zQueryPrimaryScalar<T>
    :: QueryPrimaryScalar<T> mimics QueryTerm<T>
    {}

|   qt:zQueryTerm<T> INTERSECT ALL qp:zQueryPrimaryScalar<T>
    {
        return new zAbstractQueryTerm<T>(qt, qp, true);
    }
    ::QueryTerm<T>
     {
         public QueryTerm<T> intersectAll(final zQueryPrimaryScalar<T> qps) {
            return new QueryTerm<T>(_APPLY_RULE_(this, qps));
         }
     }

|   qt:zQueryTerm<T> INTERSECT DISTINCT qp:zQueryPrimaryScalar<T>
    {
        return new zAbstractQueryTerm<T>(qt, qp, false);
    }
    :: QueryTerm<T>
     {
         public QueryTerm<T> intersectDistinct(final zQueryPrimaryScalar<T> qps) {
            return new QueryTerm<T>(_APPLY_RULE_(this, qps));
         }
     }
;

class  zAbstractQueryTerm<T> implements zQueryTerm<T> {
    private final zQueryTerm<T> qt;
    private final zQueryPrimaryScalar<T> qp;
    private final SqlTerminal allOrDistinct;

    zAbstractQueryTerm$(
        final zQueryTerm<T> qt,
        final zQueryPrimaryScalar<T> qp,
        final boolean allNotDistinct
        ) {
        this.qt = qt;
        this.qp = qp;
        this.allOrDistinct = allNotDistinct ? SqlTerminal.ALL : SqlTerminal.DISTINCT;
        }
           @Override
           public T value(final Element element) throws SQLException {
                return qt.value(element);
           }
            @Override
            public void z$prepare$zQueryTerm(final SqlContext context) {
                final SqlContext leftContext = new SqlContext();
                leftContext.set(FromClause.class, new FromClause(context.get(FromClause.class)));
                leftContext.set(ColumnNameProvider.class, new ColumnNameProvider());
                final SqlContext rightContext = new SqlContext();
                rightContext.set(FromClause.class, new FromClause(context.get(FromClause.class)));
                rightContext.set(ColumnNameProvider.class, new ColumnNameProvider());
                 qt.z$prepare$zQueryTerm(leftContext);
                 qp.z$prepare$zQueryPrimaryScalar(rightContext);
            }
            @Override
            public Query<T> z$create$zQueryTerm(final SqlContext context) {
                final SqlContext leftContext = new SqlContext();
                leftContext.set(FromClause.class, new FromClause(context.get(FromClause.class)));
                leftContext.set(ColumnNameProvider.class, new ColumnNameProvider());
                final SqlContext rightContext = new SqlContext();
                rightContext.set(FromClause.class, new FromClause(context.get(FromClause.class)));
                rightContext.set(ColumnNameProvider.class, new ColumnNameProvider());
                 qt.z$prepare$zQueryTerm(leftContext);
                 qp.z$prepare$zQueryPrimaryScalar(rightContext);
                return new CompositeQuery<T>(qt.z$create$zQueryTerm(leftContext), SqlTerminal.INTERSECT, allOrDistinct, qp.z$create$zQueryPrimaryScalar(rightContext));
            }

}

public interface zQueryPrimaryScalar<T> extends Scalar<T>  : Query<T>
{}

public class QueryPrimaryScalar<T> implements zQueryPrimaryScalar<T> with sqlBuilder
{}

<T> zQueryPrimaryScalar<T> ::= qs:zQuerySpecificationScalar<T>
    :: QuerySpecificationScalar<T> mimics QueryPrimaryScalar<T>
    {}

|  LEFT_PAREN qe:zQueryExpressionScalar<T> RIGHT_PAREN
    :: QueryExpressionScalar<T> mimics QueryPrimaryScalar<T>
    {}
;

public interface zQuerySpecificationScalar<T> extends Scalar<T> : Query<T>
{}

public class QuerySpecificationScalar<T> implements zQuerySpecificationScalar<T> with sqlBuilder
{}

<T> zQuerySpecificationScalar<T> ::= qb:zQueryBaseScalar<T>
    :: QueryBaseScalar<T> mimics QuerySpecificationScalar<T>
    {}

  |  qb:zQueryBaseScalar<T> wc:zWhereClause
    :: QueryBaseScalar<T>
    {
        public QuerySpecificationScalar<T> where(zWhereClause condition) {
            return new QuerySpecificationScalar<T>(_APPLY_RULE_(this, condition));
        }
    }
;


# zQueryBase and zQueryBaseScalar

public interface zQueryBase<T> : Query<T>
{}

public class QueryBase<T> implements zQueryBase<T> with sqlBuilder
{}

public interface zQueryBaseScalar<T> extends Scalar<T> :  Query<T>
{}

public class QueryBaseScalar<T> implements zQueryBaseScalar<T> with sqlBuilder
{}


# A single class RowValue represents both zSelectList and zRowValueExpression.
# so, all() and distinct() methods are methods of this class

public interface zSelectList<T> : Query<T>
{}


<T> zQueryBase<T> ::= SELECT sl:zSelectList<T> fc:zFromClause
    :: RowValue<T> mimics QueryBase<T>  {
    // this is a tricky part. The user never supplies zFromClause,
    // we are extracting it from Sqlcontext. So, we have only one argument
    // and can implement it transparently
    // but we have to write code of toQueryBase manually
    // providing an instance of ImplicitFromClause
        protected final QueryBase<T> toQueryBase() {
            zFromClause fromClause = new ImplicitFromClause();
            return new QueryBase<T>(_APPLY_RULE_(this, fromClause));
        }
    }

| SELECT ALL sl:zSelectList<T> fc:zFromClause
     :: RowValue<T>
     {
        public QueryBase<T> all() {
            zFromClause fromClause = new ImplicitFromClause();
            return new QueryBase<T>(_APPLY_RULE_(this, fromClause));
        }
     }

| SELECT DISTINCT sl:zSelectList<T> fc:zFromClause
     :: RowValue<T>
     {
        public QueryBase<T> distinct() {
            zFromClause fromClause = new ImplicitFromClause();
            return new QueryBase<T>(_APPLY_RULE_(this, fromClause));
        }
     }
;

# zSelectSublist
# scalar counterpart of zSelectList is zSelectSublist rather than zSelectList_scalar

<T> zQueryBaseScalar<T> ::= SELECT sl:zSelectSublist<T> fc:zFromClause
    :: SelectSublist<T> mimics QueryBaseScalar<T>  {
    // this is a tricky part. The user never supplies zFromClause,
    // we are extracting it from Sqlcontext. So, we have only one argument
    // and can implement it transparently
    // but we have to write code of toQueryBase manually
    // providing an instance of ImplicitFromClause
        protected final QueryBaseScalar<T> toQueryBaseScalar() {
            zFromClause fromClause = new ImplicitFromClause();
            return new QueryBaseScalar<T>(_APPLY_RULE_(this, fromClause));
        }
    }

| SELECT ALL sl:zSelectSublist<T> fc:zFromClause
     :: SelectSublist<T>
     {
        public QueryBaseScalar<T> all() {
            zFromClause fromClause = new ImplicitFromClause();
            return new QueryBaseScalar<T>(_APPLY_RULE_(this, fromClause));
        }
     }

| SELECT DISTINCT sl:zSelectSublist<T> fc:zFromClause
     :: SelectSublist<T>
     {
        public QueryBaseScalar<T> distinct() {
            zFromClause fromClause = new ImplicitFromClause();
            return new QueryBaseScalar<T>(_APPLY_RULE_(this, fromClause));
        }
     }
;

public interface zSelectSublist<T> extends Scalar<T> : Query<T>
{}

public class SelectSublist<T> implements zSelectSublist<T> with builder
{}

<T> zSelectList<T> ::= ssl:zSelectSublist<T>
    :: SelectSublist<T> mimics RowValue<T>
    {}
;

 // more naturally implemented as static method of Values class:
 // <L,R> RowValue<Pair<L,R> makePair(RowValue<L> l, RowValue<R> r);
 // so no class member method is defined for this production
<T,U> zSelectList<Pair<T,U>> ::= sl1:zSelectList<T> COMMA sl2:zSelectList<U>
{   return new zSelectList<Pair<T,U>>() {
        public void z$prepare$zSelectList(final SqlContext context) {
            sl1.z$prepare$zSelectList(context);
            sl2.z$prepare$zSelectList(context);
        }
        public Query<Pair<T,U>> z$create$zSelectList(final SqlContext context) {
            final Query<T> sql1 = sl1.z$create$zSelectList(context);
            final Query<U> sql2 = sl2.z$create$zSelectList(context);
            DataExtractor<Pair<T,U>> extractor = new DataExtractor<Pair<T, U>>() {
                public Pair<T, U> extract(final Row row) throws SQLException {
                    final T first = sql1.extract(row);
                    final U second = sql2.extract(row);
                    return Pair.of(first, second);
                }
            };
            return new CompoundQuery<Pair<T,U>>(extractor, new CompositeSql(sql1, SqlTerminal.COMMA, sql2));
        }
    };
}
;


# <T> zSelectSublist<T> ::= zValueExpression<T> [ AS Identifier ]
# Identifier is added automatically when needed
# SqlFactory method does not know about [ AS Identifier ]

<T> zSelectSublist<T> ::=  ve:zValueExpression<T>
{
    return new zSelectSublist<T>() {

        public void z$prepare$zSelectSublist(SqlContext context) {
            ve.z$prepare$zValueExpression(context);
        }

        public Query<T> z$create$zSelectSublist(SqlContext context) {
        final ColumnNameProvider columnNameProvider = context.get(ColumnNameProvider.class);
            final Identifier identifier = columnNameProvider.getUniqueName();
            if (identifier!=null) {
                final DataExtractor<T> extractor = new DataExtractor<T>() {
                    @Override
                    public T extract(final Row row) throws SQLException {
                        return ve.value(row.getValue(identifier.toString()));
                    }
                };
                return new CompoundQuery<T>(extractor,
                        new CompositeSql(ve.z$create$zValueExpression(context), AS, identifier));
            } else {
                // column names are not provided in this context
                return new CompoundQuery<T>(new NullDataExtractor<T>(), ve.z$create$zValueExpression(context));
            }
        }

        public T value(final Element element) throws SQLException {
            return ve.value(element);
        }
    };
}
    :: Value<T> mimics SelectSublist<T>
    {}
;











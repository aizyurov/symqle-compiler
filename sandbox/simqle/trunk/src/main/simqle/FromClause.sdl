public interface zFromClause : Sql
{}

import org.simqle.Sql;
import org.simqle.SqlContext;
/**
 * @author Alexander Izyurov
 */
public class ImplicitFromClause implements zFromClause {
    /**
     * Defines Sql produced by this syntactic element.
     * Implementations should produce Sql conforming to the productions specified above.
     *
     * @param context - construction context: dialect, tables available in this and enclosing contexts etc.
     * @return sql as required for zFromClause syntax
     */
    public Sql z$create$zFromClause(SqlContext context) {
        return context.get(FromClause.class).z$create$zFromClause(context);
    }

    public void z$prepare$zFromClause(SqlContext context) {
        // do nothing
    }
}

class FromClause implements zFromClause
import java.util.*;
import org.simqle.util.TSort;
{
    private final FromClause enclosingClause;
    private final NameGenerator nameGenerator;
    private final Map<zTable, Identifier> localTables = new HashMap<zTable, Identifier>();

    protected final NameGenerator getNameGenerator() {
        return nameGenerator;
    }

    public FromClause$(final FromClause enclosingClause) {
        this.enclosingClause = enclosingClause;
        this.nameGenerator = enclosingClause !=null ? enclosingClause.getNameGenerator() : new NameGenerator();
    }

    public FromClause$() {
        this(null);
     }

    public void z$prepare$zFromClause(SqlContext context) {
        throw new RuntimeException("This code should not be reachable");
    }

    public Sql z$create$zFromClause(final SqlContext context) {
    // TODO some RDBMS allow empty FromClause
    if (localTables.size()==0) {
        throw new IllegalStateException("No referenced tables");
    }
    TSort<zTable> tSort = new TSort<zTable>();
    for (zTable table: localTables.keySet()) {
        tSort.add(table);

        SqlContext probeContext = new SqlContext();
        final FromClause probeFrom = new FromClause();
        probeContext.set(FromClause.class, probeFrom);
        probeContext.set(SqlFactory.class, context.get(SqlFactory.class));
        table.z$prepare$zTable(probeContext);
        final Set<zTable> dependencies = probeFrom.getAllTables();
        // remove self-dependency
        dependencies.remove(table);
        for (zTable dependency: dependencies) {
            tSort.add(table, dependency);
        }
    }
    // TODO better diagnostics on IllegalSTateException
    // cyclic dependency
    final List<zTable> sortedTables = tSort.sort();
    zTable root = sortedTables.get(0);
    zTableReference ref = SqlFactory.getInstance().zTableReference_IS_zTablePrimary(root);
    int i;
    for (i = 1; i< sortedTables.size(); i++) {
        final zTable t = sortedTables.get(i);
        ref = SqlFactory.getInstance().zTableReference_IS_zTableReference_zTableJoin(ref, t);
    }
    // TODO take SqlFactory from the context
    return SqlFactory.getInstance().zFromClause_IS_FROM_zTableReference(ref).z$create$zFromClause(context);
    }

    public Identifier getCorrelationName(zTable table) {
        if (localTables.containsKey(table)) {
            Identifier name = localTables.get(table);
            if (name==null) {
                name = nameGenerator.generate();
                localTables.put(table, name);
            }
            return name;
        } else if (enclosingClause!=null) {
            return enclosingClause.getCorrelationName(table);
        } else {
            throw new IllegalStateException("Table "+table+" has not been registered in FromClause");
        }
    }

    public boolean addTable(zTable table) {
        if (!isAvailable(table)) {
            localTables.put(table, null);
            return true;
        } else {
            return false;
        }
    }

    public boolean isAvailable(zTable table) {
        return enclosingClause != null && enclosingClause.isAvailable(table) || localTables.containsKey(table);
    }

    public Set<zTable> getAllTables() {
        Set<zTable> allTables = getLocalTables();
        if (enclosingClause!=null) {
            allTables.addAll(enclosingClause.getAllTables());
        }
        return allTables;
    }

    public HashSet<zTable> getLocalTables() {
        return new HashSet<zTable>(localTables.keySet());
    }

    private static class NameGenerator {
        private int counter=0;

        private Identifier generate() {
            return new Identifier("T"+(counter++));
        }
    }

}

zFromClause ::= FROM  tr:zTableReference
;

interface zTableReference : Sql
{}

# zTableReference is used internally by FromClause; no implementing class
zTableReference ::=  tp:zTablePrimary
     | tr:zTableReference jt:zTableJoin
;

public interface zTablePrimary : Sql
{}

# used internally by Table
# Correlation name is added automatically
# zTablePrimary ::= id:Identifier [ AS Identifier ]
# zTablePrimary ::= id:Identifier


public interface zTableJoin  : Sql
{}

public abstract class Table implements zTable
import java.util.*;
{
    private boolean isJoined = false;
    private zTableJoin tableJoin;
    private zTablePrimary tablePrimary;

    private void startJoin() {
        if (isJoined) {
            throw new IllegalStateException("Double join");
        }
        isJoined = true;
    }

    protected Table$(final String name) {
        tablePrimary = new zTablePrimary() {
            @Override
            public void z$prepare$zTablePrimary(final SqlContext context) {
            // do nothing
            }
            public Sql z$create$zTablePrimary(final SqlContext context) {
                return new Identifier(name);
            }
        };
    }

    public Sql z$create$zTable(final SqlContext context)          {
                return
                 isJoined ?
                z$create$zTableJoin(context) :
                z$create$zTablePrimary(context);
            }

    public Sql z$create$zTableJoin(final SqlContext context)          {
                if (!isJoined) {
                    final Set<zTable> allTables = context.get(FromClause.class).getAllTables();
                    allTables.remove(this);
                    final List<String> tableNames = new ArrayList<String>();
                    for (zTable table: allTables) {
                        tableNames.add(table.toString());
                    }
                    throw new IllegalStateException("Implicit cross join of "+ toString() + " to "+ tableNames);
                }
                return tableJoin.z$create$zTableJoin(context);
            }

    public void z$prepare$zTable(final SqlContext context)          {
                if (isJoined) {
                    z$prepare$zTableJoin(context);
                } else {
                    z$prepare$zTablePrimary(context);
                }
            }

    public void z$prepare$zTableJoin(final SqlContext context)          {
                final FromClause fromClause = context.get(FromClause.class);
                fromClause.addTable(this);
                // propagate to dependencies
                tableJoin.z$prepare$zTableJoin(context);
            }

    public void z$prepare$zTablePrimary(final SqlContext context)          {
                final FromClause fromClause = context.get(FromClause.class);
                fromClause.addTable(this);
                tablePrimary.z$prepare$zTablePrimary(context);
            }

    public Sql z$create$zTablePrimary(final SqlContext context) {
        final FromClause fromClause = context.get(FromClause.class);
        final Sql name = tablePrimary.z$create$zTablePrimary(context);
        final Sql correlationName = fromClause.getCorrelationName(this);
        return new CompositeSql(name, SqlTerminal.AS, correlationName);
    }

}

public interface zTable extends zTablePrimary, zTableJoin : Sql
{}





zTableJoin ::=
      CROSS JOIN tp:zTablePrimary
      :: Table
      {
        public void crossJoin() {
            startJoin();
            tableJoin = _APPLY_RULE_(this);
        }
      }
|     INNER JOIN tp:zTablePrimary js:zJoinSpecification
      :: Table
      {
        public void innerJoin(final zJoinSpecification js) {
            startJoin();
            tableJoin = _APPLY_RULE_(this, js);
        }
      }
|     OUTER JOIN tp:zTablePrimary js:zJoinSpecification
      :: Table
      {
        public void outerJoin(final zJoinSpecification js) {
            startJoin();
            tableJoin = _APPLY_RULE_(this, js);
        }
      }
|     LEFT OUTER JOIN tp:zTablePrimary js:zJoinSpecification
      :: Table
      {
        public void leftJoin(final zJoinSpecification js) {
            startJoin();
            tableJoin = _APPLY_RULE_(this, js);
        }
      }
|
      RIGHT OUTER JOIN tp:zTablePrimary js:zJoinSpecification
      :: Table
      {
        public void rightJoin(final zJoinSpecification js) {
            startJoin();
            tableJoin = _APPLY_RULE_(this, js);
        }
      }
;


interface zJoinSpecification : Sql
{}


# zJoinSpecification ::= join_condition | named_columns_join
# join_condition ::= ON search_condition

# We do not support named_columns_join

zJoinSpecification ::= ON e:zBooleanValueExpression
    :: BooleanValueExpression mimics JoinSpecification
    {}
;

class JoinSpecification implements zJoinSpecification with builder
{}


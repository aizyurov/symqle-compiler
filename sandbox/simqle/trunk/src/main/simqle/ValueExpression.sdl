public interface zValueExpression<T> extends Scalar<T> : Sql
{}

public class Value<T> implements zValueExpression<T> with valueExpression
{}

# No need on CommonValueExpression: different dialects have different ranks of operations
# all operations shall take zValueExpressionPrimary and return zValueExpression
# it may lead to some extra parentheses but is harmless.
# operations have their own syntax not described in syntax rules,
# e.g. <T extends Number> zValueExpression<T> ::= e1:zValueExpressionPrimary<T> PLUS e2:zValueExpressionPrimary<T>
# it does not go to SqlFactory
<T> zValueExpression<T> ::=
		e:zValueExpressionPrimary<T>
		:: ValueExpressionPrimary<T> mimics Value<T>
		{}
;
zValueExpression<Boolean> ::= bve: zBooleanValueExpression
	    :: BooleanValueExpression mimics Value<Boolean>
	    {}
;


/*
 Most instances will be <Boolean>, but SQL allows any valid primary_zValueExpression
 and database boolean value may be mapped to another type in Java
 */
public interface zBooleanValueExpression extends Scalar<Boolean> : Sql
{}

public class BooleanValueExpression implements zBooleanValueExpression with sqlBuilder
{}


# For zBooleanValueExpression syntax is very close to sql-2003
# But not type paremeters: all methods do not have
# type parametes, return type is <Boolean> and arguments are <?>

zBooleanValueExpression ::= bt:zBooleanTerm
		    :: BooleanTerm mimics BooleanValueExpression
		    {}

    |   bve:zBooleanValueExpression OR bvt:zBooleanTerm
		:: BooleanValueExpression {
		    public BooleanValueExpression or(zBooleanTerm term) {
		        return new BooleanValueExpression(_APPLY_RULE_(this, term));
		    }
		}
;

public interface zBooleanTerm extends Scalar<Boolean> : Sql
{}

public class BooleanTerm implements zBooleanTerm with sqlBuilder
{}

zBooleanTerm ::= bf:zBooleanFactor
    :: BooleanFactor mimics BooleanTerm
    {}

   |  bt:zBooleanTerm AND bf:zBooleanFactor
	::BooleanTerm {
	    public BooleanTerm and(BooleanFactor factor) {
		        return new BooleanTerm(_APPLY_RULE_(this, factor));
	    }
	}
;

public interface zBooleanFactor extends Scalar<Boolean> : Sql
{}

public class BooleanFactor implements zBooleanFactor with sqlBuilder
{}

zBooleanFactor ::= bt:zBooleanTest
    :: BooleanTest mimics BooleanFactor
    {}

  | NOT bt:zBooleanTest
    :: BooleanTest
    {
        BooleanFactor negate() {
            return new BooleanFactor(_APPLY_RULE_(this));
        }
    }
;

public interface zBooleanTest extends Scalar<Boolean> : Sql
{}

public class BooleanTest implements zBooleanTest with sqlBuilder
{}


zBooleanTest ::= bp:zBooleanPrimary
    :: BooleanPrimary mimics BooleanTest
    {}

|  bp:zBooleanPrimary  IS  NOT  TRUE
    :: BooleanPrimary
    {
        public BooleanTest isNotTrue() {
            return new BooleanTest(_APPLY_RULE_(this));
        }
    }

|  bp:zBooleanPrimary  IS  TRUE
    :: BooleanPrimary
    {
        public BooleanTest isTrue() {
            return new BooleanTest(_APPLY_RULE_(this));
        }
    }

| bp:zBooleanPrimary  IS  NOT  FALSE
    :: BooleanPrimary
    {
        public BooleanTest isNotFalse() {
            return new BooleanTest(_APPLY_RULE_(this));
        }
    }

|  bp:zBooleanPrimary  IS  FALSE
    :: BooleanPrimary
    {
        public BooleanTest isFalse() {
            return new BooleanTest(_APPLY_RULE_(this));
        }
    }

| bp:zBooleanPrimary  IS  NOT  UNKNOWN
    :: BooleanPrimary
    {
        public BooleanTest isNotUnknown() {
            return new BooleanTest(_APPLY_RULE_(this));
        }
    }

|  bp:zBooleanPrimary  IS  UNKNOWN
    :: BooleanPrimary
    {
        public BooleanTest isUnknown() {
            return new BooleanTest(_APPLY_RULE_(this));
        }
    }
;

interface zBooleanPrimary extends Scalar<Boolean> : Sql
{}

class BooleanPrimary implements zBooleanPrimary with sqlBuilder
{}


zBooleanPrimary ::= p:zPredicate
    ::Predicate mimics BooleanPrimary
    {}

  | LEFT_PAREN bve:zBooleanValueExpression RIGHT_PAREN
    :: BooleanValueExpression mimics BooleanPrimary
    {}

  | vep:zValueExpressionPrimary<Boolean>
  :: Value<T> {
public BooleanPrimary asCondition()   {
        return new BooleanPrimary(SqlFactory.getInstance().zBooleanPrimary_IS_zValueExpressionPrimary(
                new zValueExpressionPrimary<Boolean>() {
                    @Override
                    public Sql z$create$zValueExpressionPrimary(final SqlContext context) {
                        return z$create$zValueExpression(context);
                    }

                    @Override
                    public void z$prepare$zValueExpressionPrimary(final SqlContext context) {
                        z$prepare$zValueExpression(context);
                    }

                    @Override
                    public Boolean value(final Element element) throws SQLException {
                        return element.getBoolean();
                    }
                }));
    }
  }
;



public interface zValueExpressionPrimary<T> extends Scalar<T> : Sql
{}

public class ValueExpressionPrimary<T> implements zValueExpressionPrimary<T>  with sqlBuilder
{}

<T> zValueExpressionPrimary<T> ::= LEFT_PAREN ve:zValueExpression<T> RIGHT_PAREN
    :: Value<T> mimics ValueExpressionPrimary<T>
    {}
    |
		dps:zDynamicParameterSpecification<T>
		:: DynamicParameter<T> mimics ValueExpressionPrimary<T>
		 {}
	|	cr:zColumnReference<T>
	    :: Column<T> mimics ValueExpressionPrimary<T>
	    {}
	|	sc:zScalarSubquery<T>
	    :: ScalarSubquery<T> mimics ValueExpressionPrimary<T>
	    {}
	|	ri:zRoutineInvocation<T>
	    :: RoutineInvocation<T> mimics ValueExpressionPrimary<T>
	    {}

#	|	next_zValueExpression<T>
;


public interface	zDynamicParameterSpecification<T> extends Scalar<T> : Sql
{}

public abstract class DynamicParameter<T> implements zDynamicParameterSpecification<T>
{
    @Override
    public final void z$prepare$zDynamicParameterSpecification(final SqlContext context) {
        // do nothing
    }

    @Override
    public final Sql z$create$zDynamicParameterSpecification(final SqlContext context) {
        return new Sql() {
            @Override
            public String getSqlText() {
                return SqlTerminal.QUESTION.getSqlText();
            }

            @Override
            public void setParameters(final SqlParameters p) {
                setParameter(p);
            }
        };
    }

    /**
    * To be implemented in derived classes.
    *
    */
    protected abstract void setParameter(final SqlParameters p);

    /**
    * To be implemented in derived classes.
    *
    */
    public abstract T value(final Element element) throws SQLException ;
}


public interface	zColumnReference<T> extends Scalar<T> : Sql
{}

public abstract class Column<T> implements zColumnReference<T>
{
    private final Identifier columnName;
    private final Table owner;

    protected Column$(final String name,  final Table owner)  {
            this.columnName = new Identifier(name);
            this.owner = owner;
        }
    protected final ValueExpressionPrimary<T> toValueExpressionPrimary()   {    return new ValueExpressionPrimary<T>(SqlFactory.getInstance().zValueExpressionPrimary_IS_zColumnReference(this));    }

    public Sql z$create$zColumnReference(final SqlContext context)   {
            final Identifier tableName = context.get(FromClause.class).getCorrelationName(owner);
            return new CompositeSql(tableName, SqlTerminal.PERIOD, columnName);
        }
    public void z$prepare$zColumnReference(final SqlContext context)   {
            owner.z$prepare$zTable(context);
        }

    public abstract T value(final Element element) throws SQLException ;
}

public interface	zRoutineInvocation<T>  extends Scalar<T> : Sql
{}

# there are no default implementations or zRoutineInvocation
# should be created individually
# as factory methods
# to have type-check of arguments

/*
<routine invocation> ::= <routine name> <SQL argument list>

<routine name> ::= [ <schema name> <period> ] <qualified identifier>

<SQL argument list> ::= <left paren> [ <SQL argument> [ { <comma> <SQL argument> }... ] ] <right paren>

<SQL argument> ::=
		<value expression>
	|	<generalized expression>
	|	<target specification>

Simplified, generalized expression and target specification not supported
*/

<T> zRoutineInvocation<T> ::= rn:zRoutineName<T> LEFT_PAREN al:zArgumentList RIGHT_PAREN
    :: Function<T>
    {
        protected RoutineInvocation<T> apply(zValueExpression<?> firstArg, zValueExpression<?>... otherArgs) {
                zArgumentList al = SqlFactory.getInstance().zArgumentList_IS_zValueExpression(firstArg);
                for (zValueExpression ve: otherArgs) {
                    al = SqlFactory.getInstance().zArgumentList_IS_zArgumentList_COMMA_zValueExpression(al, ve);
                }
                return new RoutineInvocation<T>(SqlFactory.getInstance().zRoutineInvocation_IS_zRoutineName_LEFT_PAREN_zArgumentList_RIGHT_PAREN(this, al));
        }
    }

    | rn:zRoutineName<T> LEFT_PAREN RIGHT_PAREN
    :: Function<T>
    {
        protected RoutineInvocation<T> apply() {
                return new RoutineInvocation<T>(_APPLY_RULE_(this));
        }
    }
;

public interface zRoutineName<T> extends Scalar<T> : Sql
{}

public interface zArgumentList : Sql
 {}

# zArgumentList is used only internally by Function; no implementing class
zArgumentList ::= ve:zValueExpression<?>
    | al:zArgumentList COMMA ve:zValueExpression<?>
;

public class RoutineInvocation<T> implements zRoutineInvocation<T> with sqlBuilder
{}

public abstract class Function<T> implements zRoutineName<T>
{
    private final zRoutineName routineName;
    protected Function$(final String name) {
        routineName = new zRoutineName<T>() {
            @Override
            public Sql z$create$zRoutineName(final SqlContext context) {
                return new Identifier(name);
            }

            @Override
            public void z$prepare$zRoutineName(final SqlContext context) {
                // do nothing
            }

            @Override
            public T value(final Element element) throws SQLException {
                return Function$.this.value(element);
            }
        };
    }

    @Override
    public final void z$prepare$zRoutineName(final SqlContext context) {
       routineName.z$prepare$zRoutineName(context);
    }

    @Override
    public final Sql z$create$zRoutineName(final SqlContext context) {
        return routineName.z$create$zRoutineName(context);
    }


        /**
        * To be implemented in derived classes.
        *
        */
    public abstract T value(final Element element) throws SQLException ;

}

